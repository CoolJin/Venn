<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Venn Diagramm Generator</title>
<style>
  :root{
    --bg:#0b0d10; --panel:rgba(20,22,28,0.65); --panel-border:rgba(255,255,255,0.09);
    --text:#e9ecf1; --sub:#a9b3c7; --neon:#00e5ff; --bad:#ff6b6b; --ok:#17e5a1;
  }
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1200px 800px at 10% 10%, rgba(168,85,247,0.08), transparent 60%),
      radial-gradient(1000px 700px at 90% 80%, rgba(0,229,255,0.08), transparent 60%),
      var(--bg);
    color:var(--text);
    font: 15px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow-x:hidden; cursor:none;
  }
  /* smoother custom cursor */
  .cursor{ position:fixed; inset:auto; left:0; top:0; width:18px; height:18px; border:2px solid var(--neon);
           border-radius:50%; pointer-events:none; mix-blend-mode:screen; filter:drop-shadow(0 0 6px var(--neon));
           transform:translate(-50%,-50%); z-index:9999; transition:transform .12s ease; }
  .cursor:after{content:""; position:absolute; inset:2px; border-radius:50%; border:1px solid rgba(255,255,255,0.4)}

  .wrap{ max-width:92vw; margin:2vh auto; padding:0 1vw; }
  .header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
  .title{ font-size:22px; font-weight:800; letter-spacing:.3px }

  .card{ position:relative; padding:14px; border-radius:22px; background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.025));
         border:1px solid var(--panel-border); backdrop-filter:blur(12px); box-shadow:0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04) }
  .card h3{ margin:4px 0 10px; font-size:14px; color:var(--sub); font-weight:600; letter-spacing:.2px }

  .controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px }
  .input{ flex:1 1 520px; display:flex; gap:8px; align-items:center }
  .input input{ flex:1; background:rgba(255,255,255,0.04); border:1px solid var(--panel-border); border-radius:14px; padding:10px 12px; color:var(--text);
                outline:none; transition:.2s border,.2s box-shadow; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02) }
  .input input:focus{ border-color:rgba(0,229,255,0.4); box-shadow:0 0 0 3px rgba(0,229,255,0.12) }

  .btn{ border:1px solid var(--panel-border); background:rgba(255,255,255,0.02); color:var(--text); padding:8px 10px; border-radius:12px; cursor:pointer; backdrop-filter:blur(8px);
        transition:transform .06s, border-color .2s, background .2s, box-shadow .2s }
  .btn:hover{ border-color:rgba(255,255,255,0.2); box-shadow:0 0 14px rgba(0,229,255,0.10) }
  .btn:active{ transform:translateY(1px) scale(.99) }
  .btn.primary{ border-color:rgba(0,229,255,0.35); box-shadow:0 0 16px rgba(0,229,255,0.12), inset 0 0 0 1px rgba(0,229,255,0.06);
                background:linear-gradient(180deg, rgba(0,229,255,0.12), rgba(0,229,255,0.07)) }

  .toggle{ display:flex; gap:10px; align-items:center }
  .toggle input{ accent-color:var(--neon) }

  .chips{ display:flex; flex-wrap:wrap; gap:6px }
  .chip{ border:1px dashed rgba(255,255,255,0.18); border-radius:12px; padding:6px 8px; color:var(--sub); cursor:pointer; transition:.15s border-color,.15s color,.15s transform }
  .chip:hover{ border-color:rgba(255,255,255,0.35); color:var(--text); transform:translateY(-1px) }

  .canvasWrap{ position:relative; border-radius:18px; overflow:hidden; border:1px solid var(--panel-border); background:rgba(10,12,16,0.78);
               box-shadow:0 10px 30px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.03); animation:glowPulse 4s ease-in-out infinite alternate }
  @keyframes glowPulse{ 0%{ box-shadow:0 10px 30px rgba(0,0,0,0.35), 0 0 0 rgba(0,229,255,0)} 100%{ box-shadow:0 10px 30px rgba(0,0,0,0.35), 0 0 44px rgba(0,229,255,0.10)} }
  #venn{ width:100%; height:80vh; display:block }

  table{ width:100%; border-collapse:collapse; margin-top:12px }
  thead th{ text-align:left; font-weight:700; font-size:12px; color:var(--sub); border-bottom:1px solid var(--panel-border); padding:8px }
  tbody td{ border-bottom:1px dashed rgba(255,255,255,0.09); padding:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
  tbody tr:nth-child(odd){ background:rgba(255,255,255,0.02) }
  .warn{ color:var(--bad); font-size:12px; margin-left:6px }

  .tests{ margin-top:12px; font-size:13px; color:var(--sub) }
  .tests .pass{ color:var(--ok) }
  .tests .fail{ color:var(--bad) }

  @media (max-width:900px){ .wrap{max-width:96vw} #venn{height:70vh} }
</style>
</head>
<body>
<div class="cursor" id="cursor"></div>
<div class="wrap">
  <div class="header"><div class="title">Venn Diagramm Generator</div></div>

  <div class="card">
    <h3>Ausdruck & Darstellung</h3>
    <div class="controls">
      <div class="input">
        <input id="expr" spellcheck="false" placeholder="z. B. (A ∨ B) ∧ (A ∨ C)" />
        <button class="btn primary" id="btnRender">Rendern</button>
        <button class="btn" id="btnExport">PNG</button>
      </div>
      <div class="toggle">
        <label><input type="radio" name="mode" value="3" checked> 3 Mengen</label>
        <label><input type="radio" name="mode" value="2"> 2 Mengen</label>
        <span class="warn" id="warnC" style="display:none">C wird im 2‑Mengen‑Modus ignoriert.</span>
      </div>
    </div>

    <div class="chips" id="chips"></div>

    <div class="canvasWrap">
      <canvas id="venn" width="1000" height="600"></canvas>
    </div>

    <table>
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>

    <div id="tests" class="tests"></div>
  </div>
</div>

<script>
  // ---------- Smooth cursor ----------
  const cursor = document.getElementById('cursor');
  let tx=0, ty=0, cx=0, cy=0;
  window.addEventListener('mousemove', e=>{ tx = e.clientX; ty = e.clientY; });
  (function raf(){ cx += (tx - cx)*0.16; cy += (ty - cy)*0.16; cursor.style.left = cx + 'px'; cursor.style.top = cy + 'px'; requestAnimationFrame(raf); })();
  window.addEventListener('mousedown', ()=>{ cursor.style.transform = 'translate(-50%,-50%) scale(0.86)'; });
  window.addEventListener('mouseup',   ()=>{ cursor.style.transform = 'translate(-50%,-50%) scale(1)';   });

  // ---------- UI refs ----------
  const exprEl = document.getElementById('expr');
  const warnC = document.getElementById('warnC');
  const venn = document.getElementById('venn');
  const ctx = venn.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  function resizeCanvas(){
    const rect = venn.getBoundingClientRect();
    venn.width  = Math.floor(rect.width * DPR);
    venn.height = Math.floor(rect.height * DPR);
  }
  new ResizeObserver(resizeCanvas).observe(venn);
  resizeCanvas();

  // ---------- Chips (ohne A\\B und ^ in der UI) ----------
  const chipsWrap = document.getElementById('chips');
  [
    {t:'A',v:'A'},{t:'B',v:'B'},{t:'C',v:'C'},
    {t:'(',v:'('},{t:')',v:')'},
    {t:'¬',v:'¬'},{t:'∧',v:'∧'},{t:'∨',v:'∨'},{t:'→',v:'->'},{t:'↔',v:'<->'}
  ].forEach(c=>{
    const b=document.createElement('div'); b.className='chip'; b.textContent=c.t; b.title='Einfügen';
    b.onclick=()=>insertAtCursor(exprEl,c.v); chipsWrap.appendChild(b);
  });

  function insertAtCursor(input, text){
    const [s,e] = [input.selectionStart, input.selectionEnd];
    const val = input.value; input.value = val.slice(0,s) + text + val.slice(e);
    const p = s + text.length; input.selectionStart = input.selectionEnd = p; input.focus();
  }

  // ---------- Parser ----------
  class ParseError extends Error{ constructor(msg){ super(msg); this.name='ParseError'; } }

  const OP = {
    NOT: {prec:5, assoc:'right', arity:1},
    AND: {prec:4, assoc:'left',  arity:2},
    OR:  {prec:2, assoc:'left',  arity:2},
    XOR: {prec:3, assoc:'left',  arity:2}, // unterstützt, aber kein Chip
    IMPLIES:{prec:1, assoc:'right', arity:2},
    IFF: {prec:0, assoc:'right', arity:2},
    DIFF:{prec:4, assoc:'left',  arity:2}  // unterstützt, aber kein Chip
  };

  function normalizeExpr(s){
    return s
      .replace(/→/g,'->').replace(/↔/g,'<->')
      .replace(/\bnicht\b/gi,'~')
      .replace(/\bund\b/gi,'&')
      .replace(/\boder\b/gi,'|')
      .replace(/\bxor\b/gi,'^');
  }
  const MULTI = ['<->','->'];

  function tokenize(src){
    const s = normalizeExpr(src);
    const tok = [];
    let i=0;
    while(i<s.length){
      const ch = s[i];
      if(/\s/.test(ch)){ i++; continue; }
      let matched=false;
      for(const m of MULTI){
        if(s.startsWith(m,i)){
          tok.push(['OP', m==='->'?'IMPLIES':'IFF']);
          i+=m.length; matched=true; break;
        }
      }
      if(matched) continue;
      if(ch==='('){ tok.push(['LPAREN','(']); i++; continue; }
      if(ch===')'){ tok.push(['RPAREN',')']); i++; continue; }
      if(/[ABC]/.test(ch)){ tok.push(['VAR',ch]); i++; continue; }
      if(ch==='¬' || ch==='!' || ch==='~'){ tok.push(['OP','NOT']); i++; continue; }
      if(ch==='∧' || ch==='&'){ tok.push(['OP','AND']); i++; continue; }
      if(ch==='∨' || ch==='|'){ tok.push(['OP','OR']); i++; continue; }
      if(ch==='^' || ch==='⊕'){ tok.push(['OP','XOR']); i++; continue; }
      if(ch==='\\'){ tok.push(['OP','DIFF']); i++; continue; }
      throw new ParseError(`Unbekanntes Zeichen an Pos ${i}: '${ch}'`);
    }
    return tok;
  }

  function toRPN(tokens){
    const out=[]; const st=[];
    for(const [tt,tv] of tokens){
      if(tt==='VAR'){ out.push([tt,tv]); continue; }
      if(tt==='OP'){
        while(st.length && st[st.length-1][0]==='OP'){
          const top = st[st.length-1][1];
          const topI = OP[top]; const curI = OP[tv];
          if(topI.prec>curI.prec || (topI.prec===curI.prec && curI.assoc==='left')) out.push(st.pop()); else break;
        }
        st.push([tt,tv]); continue;
      }
      if(tt==='LPAREN'){ st.push([tt,tv]); continue; }
      if(tt==='RPAREN'){
        let found=false; while(st.length){ const x=st.pop(); if(x[0]==='LPAREN'){ found=true; break;} out.push(x);} if(!found) throw new ParseError('Fehlende (');
        continue;
      }
      throw new ParseError('Tokenfehler');
    }
    while(st.length){ const x=st.pop(); if(x[0]==='LPAREN') throw new ParseError('Klammern nicht balanciert'); out.push(x);} 
    return out;
  }

  function evalRPN(rpn, ctx){
    const st=[];
    for(const [tt,tv] of rpn){
      if(tt==='VAR'){ st.push(!!ctx[tv]); continue; }
      if(tt==='OP'){
        const ar = OP[tv].arity;
        if(ar===1){ const a = !!st.pop(); st.push(!a); continue; }
        const b = !!st.pop(); const a = !!st.pop();
        switch(tv){
          case 'AND': st.push(a && b); break;
          case 'OR': st.push(a || b); break;
          case 'XOR': st.push((a&&!b)||(!a&&b)); break;
          case 'IMPLIES': st.push((!a)||b); break;
          case 'IFF': st.push((a&&b)||(!a&&!b)); break;
          case 'DIFF': st.push(a && !b); break;
          default: throw new ParseError('Unbekannter Operator '+tv);
        }
        continue;
      }
      throw new ParseError('RPN-Fehler');
    }
    if(st.length!==1) throw new ParseError('Ausdruck fehlerhaft');
    return !!st[0];
  }

  // ---------- Pretty expr for table header ----------
  function escHTML(s){ return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch])); }
  function prettyExpr(s){
    s = s.replace(/\bnicht\b/gi,'¬').replace(/\bund\b/gi,'∧').replace(/\boder\b/gi,'∨');
    s = s.replace(/<->/g,'↔').replace(/->/g,'→').replace(/\|/g,'∨').replace(/&/g,'∧').replace(/~/g,'¬');
    return escHTML(s);
  }

  // ---------- Geometry (fixed: no stray braces) ----------
  function centersAndR(mode){
    const w = venn.width, h = venn.height;
    if(mode===3){
      const r = Math.min(w,h)*0.27; // größere, übersichtlichere Kreise
      return { r,
        A:{x:w*0.35, y:h*0.62},
        B:{x:w*0.65, y:h*0.62},
        C:{x:w*0.50, y:h*0.34}
      };
    } else {
      const r = Math.min(w,h)*0.32;
      return { r,
        A:{x:w*0.42, y:h*0.55},
        B:{x:w*0.58, y:h*0.55}
      };
    }
  }
  function inside(x,y,c,r){ const dx=x-c.x, dy=y-c.y; return dx*dx+dy*dy <= r*r; }

  // ---------- Render ----------
  function render(){
    const raw = exprEl.value.trim();
    const mode = +document.querySelector('input[name="mode"]:checked').value;
    warnC.style.display = (mode===2 && /\bC\b/.test(raw)) ? 'inline' : 'none';

    let rpn;
    try{ rpn = toRPN(tokenize(raw)); }
    catch(e){ drawBackdrop(); drawMessage('Parse-Fehler: '+e.message); updateTable(null, mode); return; }

    drawVenn(rpn, mode);
    updateTable(rpn, mode);
    runTests();
  }

  function drawBackdrop(){
    ctx.save(); ctx.clearRect(0,0,venn.width,venn.height);
    const grd = ctx.createLinearGradient(0,0,0,venn.height);
    grd.addColorStop(0,'rgba(8,10,14,0.98)'); grd.addColorStop(1,'rgba(8,10,14,0.90)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,venn.width,venn.height); ctx.restore();
  }
  function drawMessage(msg){
    ctx.save(); ctx.fillStyle='rgba(255,255,255,0.08)';
    if(ctx.roundRect){ ctx.roundRect(20*DPR,20*DPR, venn.width-40*DPR, 60*DPR, 14*DPR); ctx.fill(); }
    ctx.fillStyle='#e9ecf1'; ctx.font = `${16*DPR}px Inter, system-ui, sans-serif`; ctx.textAlign='center';
    ctx.fillText(msg, venn.width/2, 60*DPR); ctx.restore();
  }

  function drawVenn(rpn, mode){
    drawBackdrop();
    const geom = centersAndR(mode);
    const img = ctx.createImageData(venn.width, venn.height);
    const data = img.data; const c1 = {r:0, g:229, b:255};

    for(let y=0; y<venn.height; y++){
      for(let x=0; x<venn.width; x++){
        let A=false,B=false,C=false;
        if(mode===3){ A=inside(x,y,geom.A,geom.r); B=inside(x,y,geom.B,geom.r); C=inside(x,y,geom.C,geom.r); }
        else { A=inside(x,y,geom.A,geom.r); B=inside(x,y,geom.B,geom.r); }
        if(evalRPN(rpn, {A,B,C})){
          const idx = (y*venn.width + x)*4;
          data[idx] = c1.r; data[idx+1] = c1.g; data[idx+2] = c1.b; data[idx+3] = 68;
        }
      }
    }
    ctx.putImageData(img,0,0);

    // Kreise + Labels mittig
    ctx.save();
    ctx.lineWidth = 2*DPR; ctx.strokeStyle = 'rgba(255,255,255,0.95)';
    ctx.shadowColor = 'rgba(0,229,255,0.30)'; ctx.shadowBlur = 8*DPR;
    const circle = c => { ctx.beginPath(); ctx.arc(c.x,c.y,geom.r,0,Math.PI*2); ctx.stroke(); };
    circle(geom.A); circle(geom.B); if(mode===3) circle(geom.C);

    ctx.shadowBlur = 0; ctx.fillStyle = '#e9ecf1'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = `${18*DPR}px Inter, system-ui, sans-serif`;
    ctx.fillText('A', geom.A.x, geom.A.y);
    ctx.fillText('B', geom.B.x, geom.B.y);
    if(mode===3) ctx.fillText('C', geom.C.x, geom.C.y);
    ctx.restore();
  }

  // ---------- Truth table ----------
  function updateTable(rpn, mode){
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    thead.innerHTML=''; tbody.innerHTML='';

    const label = prettyExpr(exprEl.value.trim());
    const cols = mode===3 ? ['A','B','C', label] : ['A','B', label];
    thead.innerHTML = `<tr>${cols.map(c=>`<th>${c}</th>`).join('')}</tr>`;

    if(!rpn) return;

    const n = mode===3 ? 3 : 2;
    const rows = 1<<n;
    for(let k=0;k<rows;k++){
      const A = !!((k>>(n-1-0))&1);
      const B = !!((k>>(n-1-1))&1);
      const C = n===3 ? !!((k>>(n-1-2))&1) : false;
      const f = evalRPN(rpn, {A,B,C});
      const vals = n===3 ? [A,B,C,f] : [A,B,f];
      tbody.insertAdjacentHTML('beforeend', `<tr>${vals.map(v=>`<td>${v?1:0}</td>`).join('')}</tr>`);
    }
  }

  // ---------- Tests ----------
  function truthVector(expr, n){
    const rpn = toRPN(tokenize(expr));
    const vec = [];
    for(let k=0;k<(1<<n);k++){
      const A = !!((k>>(n-1-0))&1);
      const B = !!((k>>(n-1-1))&1);
      const C = n===3 ? !!((k>>(n-1-2))&1) : false;
      vec.push( evalRPN(rpn, {A,B,C}) ? 1 : 0 );
    }
    return vec;
  }
  function eq(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

  function runTests(){
    const out = [];
    // 2‑Variablen‑Tests (Reihenfolge der Zeilen: AB = 00,01,10,11)
    try{
      const t2 = [
        {name:'A & B (2V)', got: truthVector('A & B',2), exp:[0,0,0,1]},
        {name:'A | B (2V)', got: truthVector('A | B',2), exp:[0,1,1,1]},
        {name:'A -> B (2V)', got: truthVector('A -> B',2), exp:[1,1,0,1]},
        {name:'A <-> B (2V)', got: truthVector('A <-> B',2), exp:[1,0,0,1]},
        {name:'¬A (2V)', got: truthVector('~A',2), exp:[1,1,0,0]}
      ];
      t2.forEach(t=> out.push({name:t.name, ok:eq(t.got,t.exp), got:t.got, exp:t.exp}));
    }catch(e){ out.push({name:'Parser/2V', ok:false, err:e.message}); }

    // 3‑Variablen‑Tests (Zeilen: ABC = 000..111)
    try{
      const t3 = [
        {name:'A & B (3V)', got: truthVector('A & B',3), exp:[0,0,0,0,0,0,1,1]},
        {name:'A | B (3V)', got: truthVector('A | B',3), exp:[0,0,1,1,1,1,1,1]},
        {name:'A -> B (3V)', got: truthVector('A -> B',3), exp:[1,1,1,1,0,0,1,1]}
      ];
      t3.forEach(t=> out.push({name:t.name, ok:eq(t.got,t.exp), got:t.got, exp:t.exp}));

      // Äquivalenztest: (A ∨ B) ∧ (A ∨ C) ≡ A ∨ (B ∧ C)
      const left = truthVector('(A | B) & (A | C)',3);
      const right = truthVector('A | (B & C)',3);
      out.push({name:'Distributiv‑Äquivalenz', ok:eq(left,right), got:left, exp:right});
    }catch(e){ out.push({name:'Parser/3V', ok:false, err:e.message}); }

    // Render Ergebnis
    const el = document.getElementById('tests');
    const okCount = out.filter(t=>t.ok).length;
    const total = out.length;
    el.innerHTML = `<div>Tests: <span class="${okCount===total?'pass':'fail'}">${okCount}/${total} ${okCount===total?'bestanden':'fehler'}</span></div>` +
      '<ul style="margin:6px 0 0 16px; padding:0">' +
      out.map(t=>`<li>${t.ok?'✅':'❌'} ${t.name}${t.err?` — ${t.err}`:''}</li>`).join('') + '</ul>';
  }

  // ---------- Events ----------
  document.getElementById('btnRender').onclick = render;
  document.getElementsByName('mode').forEach(r=> r.addEventListener('change', render));
  exprEl.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); render(); } });

  // Export
  document.getElementById('btnExport').onclick = ()=>{
    const tmp = document.createElement('canvas'); tmp.width = venn.width; tmp.height = venn.height;
    const tctx = tmp.getContext('2d'); tctx.fillStyle = '#0b0d10'; tctx.fillRect(0,0,tmp.width,tmp.height); tctx.drawImage(venn,0,0);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = 'venn.png'; a.click();
  };

  // Initial
  exprEl.value='(A ∨ B) ∧ (A ∨ C)';
  render();
</script>
</body>
</html>
